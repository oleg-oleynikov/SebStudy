worker_processes auto;
events { worker_connections 1024; }

http {

    lua_package_path "/usr/local/openresty/lualib/?.lua;;";

    resolver 127.0.0.11;
    upstream sso_service {
        server sso:50051;
    }

    upstream company_service {
        server company:50052;
    }

    upstream vacancy_service {
        server vacancy:50053;
    }

    upstream resume_service {
        server resume:50055;
    }

    upstream application_vacancy_service {
        server application-vacancy:50056;
    }
    upstream student_service {
        server student-service:50057;
    }

    server {
        listen 81;
        http2 on;
        ignore_invalid_headers off;

        location ~ /pb.SSOServerService/(Logout|ChangePassword|ChangeEmail|LogoutFromDevices) {
            auth_request /check;
            grpc_set_header Authorization $http_authorization;
            grpc_set_header X-Real-IP $remote_addr;
            grpc_read_timeout 5s;
            grpc_pass grpc://sso_service;
        }

         location ~ /pb.SSOServerService/(SendOTP|CheckOTP|RestorePassword|SignUp|RotateTokens|Login|VerifyToken) {
            grpc_pass grpc://sso_service;
            grpc_set_header X-Real-IP $remote_addr;
            grpc_read_timeout 5s;
        }

        location ~ /company.CompanyService/(CreateCompany|ChangeCompany|GetCompanyByAccessToken) {
            auth_request /check;
            grpc_set_header Authorization $http_authorization;
            grpc_set_header X-Real-IP $remote_addr;
            grpc_read_timeout 5s;
            grpc_pass grpc://company_service;
        }

        location ~ /company.CompanyService/(GetCompany|GetCompaniesByFilters|GetCompanyById|SearchCompany) {
            grpc_pass grpc://company_service;
            grpc_set_header X-Real-IP $remote_addr;
            grpc_read_timeout 5s;
        }

        location ~ /vacancy.VacancyService/(CreateVacancy|UpdateVacancy) {
            auth_request /check;
            grpc_set_header Authorization $http_authorization;
            grpc_set_header X-Real-IP $remote_addr;
            grpc_read_timeout 5s;
            grpc_pass grpc://vacancy_service;
        }

        location ~ /vacancy.VacancyService/(GetVacanciesByParams|GetVacancyById) {
            grpc_pass grpc://vacancy_service;
            grpc_set_header X-Real-IP $remote_addr;
            grpc_read_timeout 5s;
        }

        location ~ /resume.ResumeService/(CreateResume|ChangeResume) {
            # rewrite_by_lua_block {
            #     local cors = require("cors")
            #     cors("localhost:81")
            # }
            auth_request /check;
            grpc_set_header Authorization $http_authorization;
            grpc_set_header X-Real-IP $remote_addr;
            grpc_read_timeout 5s;
            grpc_pass grpc://resume_service;
        }

        location ~ /resume.ResumeService/(GetResumeByAccountId|GetResumeById) {
            grpc_pass grpc://application_vacancy_service;
            grpc_set_header X-Real-IP $remote_addr;
            grpc_read_timeout 5s;
        }
        location ~ /pb.ApplicationVacancyService/(CreateApplicationVacancy|ReviewApplicationVacancy|AcceptApplicationVacancy|RejectApplicationVacancy) {
            auth_request /check;
            grpc_set_header Authorization $http_authorization;
            grpc_set_header X-Real-IP $remote_addr;
            grpc_read_timeout 5s;
            grpc_pass grpc://application_vacancy_service;
        }

        location ~ /student.StudentService/(CreateStudent|UpdateStudent|GetStudentByID|GetStudentByToken) {
            auth_request /check;
            grpc_set_header Authorization $http_authorization;
            grpc_set_header X-Real-IP $remote_addr;
            grpc_read_timeout 5s;
            grpc_pass grpc://student_service;
        }
        location ~ /student.StudentService/(TokenExists|ListStudents) {
            grpc_set_header Authorization $http_authorization;
            grpc_set_header X-Real-IP $remote_addr;
            grpc_read_timeout 5s;
            grpc_pass grpc://student_service;
        }

        location /check {
            internal;
            rewrite_by_lua_block {
            ngx.header.content_type = "text/html"
            ngx.log(ngx.ERR, "gRPC Lua block triggered")

            local headers = ngx.req.get_headers()["Authorization"]
            local token = headers
            if not token then
                ngx.status = ngx.HTTP_OK
                ngx.header["grpc-status"] = 7
                ngx.header["grpc-message"] = "Authorization header missing"
                return ngx.exit(ngx.HTTP_FORBIDDEN)
            end

            local token_value = token:gsub("^Bearer%s+", "")
            ngx.log(ngx.ERR, "Token: ", token_value)

            local redis = require "resty.redis"
            local red = redis:new()
            red:set_timeout(1000)

            local ok, err = red:connect("redis", 6379)
            if not ok then
                ngx.log(ngx.ERR, "Failed to connect to Redis: ", err)
                ngx.status = ngx.HTTP_OK
                ngx.header["grpc-status"] = 14
                ngx.header["grpc-message"] = "Service unavailable"
                return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
            end
            local res, err = red:auth("my-password")
            if not res then
                ngx.log(ngx.ERR, "Failed to authenticate with Redis: ", err)
                return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
            end
            local db, err = red:select(1)
            if not db then
                ngx.log(ngx.ERR, "Failed to select Redis DB: ", err)
                ngx.status = ngx.HTTP_OK
                ngx.header["grpc-status"] = 13
                ngx.header["grpc-message"] = "Internal server error"
                return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
            end

            local res, err = red:get(token_value)

            if err then
                ngx.log(ngx.ERR, "Redis error: ", err)
                ngx.status = ngx.HTTP_OK
                ngx.header["grpc-status"] = 13
                ngx.header["grpc-message"] = "Redis error"
                return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
            end

            if res == ngx.null then

                ngx.log(ngx.ERR, "Redis returned null")
                red:set_keepalive(10000, 100)
                ngx.status = ngx.HTTP_OK
                ngx.header["grpc-status"] = 0
                ngx.header["grpc-message"] = "Success"
                return ngx.exit(ngx.HTTP_OK)
            else
                ngx.log(ngx.ERR, "Unauthorized access, token found in Redis")
                red:set_keepalive(10000, 100)
                ngx.status = ngx.HTTP_OK
                ngx.header["grpc-status"] = 7
                ngx.header["grpc-message"] = "Unauthorized"
                return ngx.exit(ngx.HTTP_FORBIDDEN)
            end
                }
            }
    }
}
